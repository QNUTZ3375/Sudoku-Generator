/* autogenerated by Processing revision 1293 on 2024-04-30 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.Arrays;
import java.util.Set;
import java.util.HashSet;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Sudoku extends PApplet {




int cols = 9;
int rows = 9;
int cellSize = 60;
int xStartPos = 80;
int yStartPos = 80;
int yCandidatePos = 25 + 2 * yStartPos + rows * cellSize;
int currX = 0;
int currY = 0;
boolean isOnCell = false;
Cell[][] board = new Cell[cols][rows];
int[][] candidates = new int[cols][2];
PFont mainCandidateFont;
PFont amountOfCandidatesLeft;
PFont smallCandidate;
PFont timerFont;
PFont difficultyFont;
int[][] solution = new int[cols][rows];
String[] allSolutions = {};
String[] currSolution = new String[cols * rows];
int finalDiff = 0;
int currBranches = 0;
int emptySpaces = 0;
boolean candidateMode = false;
boolean finishedPuzzle = false;
int puzzleState = 0; //determines whether the puzzle equals the solution; 1 = correct, -1 = incorrect
float threshold = 0.7f; //represents the threshold for how many clues to be removed vs added, 0 = always add, 1 = always remove
int timer = 0;
boolean showDifficulty = false;
int maxDiff = 500;


public void resetBoard(){
  puzzleState = 0;
  for(int i = 0; i < cols; i++){
    for(int j = 0; j < rows; j++){
      board[i][j].reset();
    }
  }
}

public void checkBoardState(){
  finishedPuzzle = true;
  for(int i = 0; i < cols; i++){
    for(int j = 0; j < rows; j++){
      if(board[i][j].num != solution[i][j]){
        println(board[i][j].num, solution[i][j], i, j);
        finishedPuzzle = false;
        puzzleState = -1;
        return;
      }
    }
  }
  puzzleState = 1;
  return;
}

public void generateRemainingDigits(){
  for(int i = 0; i < candidates.length; i++){
    candidates[i][1] = 9;
  }
  
  for(int i = 0; i < cols; i++){
    for(int j = 0; j < rows; j++){
      if(board[i][j].num > 0){
        candidates[board[i][j].num - 1][1]--;
      }
    }
  }
}

public int[][] copySolution(int[][] toCopyTo){
  for(int i = 0; i < cols; i++){
    for(int j = 0; j < rows; j++){
      toCopyTo[i][j] = board[i][j].num;
    }
  }
  return toCopyTo;
}

public void highlightSameNumbers(int x, int y){
  for(int i = 0; i < cols; i++){
    for(int j = 0; j < rows; j++){
      if(board[x][y].num == board[i][j].num){
        fill(255, 0, 255, 100);
        square(xStartPos + i * cellSize, yStartPos + j * cellSize, cellSize);
      }
      for(int k = 0; k < board[x][y].candidateArr.length; k++){
        if(board[i][j].candidateArr[k] && k + 1 == board[x][y].num){
          fill(200, 100, 0, 150);
          int defaultX = xStartPos + i * cellSize;
          int defaultY = yStartPos + j * cellSize;
          square(defaultX + cellSize/12 + (k % 3) * cellSize/3, defaultY + cellSize/12 + (k/3) * cellSize/3, cellSize/6 + 2);
        }
      }
    }
  }
}

public void highlightRowColumnBox(int x, int y){
  fill(0, 250, 250, 100);
  noStroke();
  for(int i = 0; i < cols/3; i++){
    if(y < i * 3 || y >= i * 3 + rows/3){
      rect(xStartPos + x * cellSize, yStartPos + i * 3 * cellSize, cellSize, cols/3 * cellSize); //column
    }
    if(x < i * 3 || x >= i * 3 + cols/3){
      rect(xStartPos + i * 3 * cellSize, yStartPos + y * cellSize, rows/3 * cellSize, cellSize);
    }
  }
  rect(xStartPos + (x/3 * 3) * cellSize, yStartPos + (y/3 * 3) * cellSize, cellSize * cols/3, cellSize * rows/3);
}

public void showCandidates(){
  if(candidateMode){
    noStroke();
    fill(0, 255, 200, 100);
    rect(0, 2 * yStartPos + rows * cellSize, 2 * xStartPos + cols * cellSize, height - 2 * yStartPos + rows * cellSize);
  }
  stroke(0);
  strokeWeight(2);
  line(0, 2 * yStartPos + rows * cellSize, 2 * xStartPos + cols * cellSize, 2 * yStartPos + rows * cellSize);
  line(xStartPos, yCandidatePos + cellSize, xStartPos + cols * cellSize, yCandidatePos + cellSize);
  strokeWeight(1);
  for(int i = 0; i < candidates.length - 1; i++){
    line(xStartPos + (i + 1) * cellSize, yCandidatePos, xStartPos + (i + 1) * cellSize, yCandidatePos + 2 * cellSize);
  }
  fill(0);
  for(int i = 0; i < candidates.length; i++){
    textFont(mainCandidateFont, 40);
    text(candidates[i][0], xStartPos + i * cellSize + cellSize/2, yCandidatePos + cellSize/2);
    textFont(amountOfCandidatesLeft, 40);
    text(candidates[i][1], xStartPos + i * cellSize + cellSize/2, yCandidatePos + cellSize + cellSize/2);
  }
}

public void drawBoardOutline(){
  noFill();
  strokeWeight(2);
  stroke(0);
  rect(xStartPos, yStartPos, cols * cellSize, rows * cellSize);
  line(xStartPos + cols * 1/3 * cellSize, yStartPos, xStartPos + cols * 1/3 * cellSize, yStartPos + rows * cellSize);
  line(xStartPos + cols * 2/3 * cellSize, yStartPos, xStartPos + cols * 2/3 * cellSize, yStartPos + rows * cellSize);
  line(xStartPos, yStartPos + rows * 1/3 * cellSize, xStartPos + cols * cellSize, yStartPos + rows * 1/3 * cellSize);
  line(xStartPos, yStartPos + rows * 2/3 * cellSize, xStartPos + cols * cellSize, yStartPos + rows * 2/3 * cellSize);
}

public void setup(){
  /* size commented out by preprocessor */;
  mainCandidateFont = createFont("HelveticaNeue", cellSize * 2/3, true);
  amountOfCandidatesLeft = createFont("HelveticaNeue-Light", cellSize * 2/3, true);
  smallCandidate = createFont("HelveticaNeue-Light", cellSize / 5, true);
  timerFont = createFont("HelveticaNeue-Thin", cellSize * 3/5, true);
  difficultyFont = createFont("HelveticaNeue-Bold", cellSize / 2, true);
  textAlign(CENTER, CENTER);
  for(int i = 0; i < cols; i++){
    for(int j = 0; j < rows; j++){
      board[i][j] = new Cell(i, j);
    }
  }
  for(int i = 0; i < candidates.length; i++){
    candidates[i][0] = i + 1;
  }
  generateRandomSudoku();
  generateRemainingDigits();
  println("Random Sudoku Generated");
}

public void draw(){
  background(240);
  showCandidates();
  fill(0, 0, 190);
  rect(2 * xStartPos + cols * cellSize, 0, width - (2 * xStartPos + cols * cellSize), height);
  textFont(timerFont, cellSize * 3/5);
  fill(255);
  text("Time: " + timer/3600 + "m " + (timer/60) % 60 + 's', (width - (2 * xStartPos + cols * cellSize))/2 + 2 * xStartPos + cols * cellSize, 100);
  if(showDifficulty){
    textFont(difficultyFont, cellSize /2);
    fill(0);
    text("Difficulty rating: ~" + finalDiff, xStartPos + cols * cellSize - 100, yStartPos - 40);
  }
  if(isOnCell){
    highlightRowColumnBox(currX, currY);
    if(board[currX][currY].num > 0){
      highlightSameNumbers(currX, currY);
    }
  }  
  for(int i = 0; i < cols; i++){
    for(int j = 0; j < rows; j++){
      board[i][j].show();
    }
  }
  drawBoardOutline();
  strokeWeight(20);
  noFill();
  switch(puzzleState){
    case 1:
      stroke(0, 255, 0);
      circle((width - (2 * xStartPos + cols * cellSize))/2 + 2 * xStartPos + cols * cellSize, 550, 150);
      break;
    case -1:
      stroke(255, 0, 0);
      line(xStartPos + cols * cellSize + 155, 475, xStartPos + cols * cellSize + 305, 625);
      line(xStartPos + cols * cellSize + 305, 475, xStartPos + cols * cellSize + 155, 625);
      break;
    default:
  }
  if(!finishedPuzzle){
    timer++;
  }
}

public void keyPressed(){
  if(!finishedPuzzle){
    if(key == BACKSPACE){
      if(board[currX][currY].cellType == "Clue"){
        return;
      }
      puzzleState = 0;
      board[currX][currY].num = 0;
      for(int i = 0; i < board[currX][currY].candidateArr.length; i++){
        board[currX][currY].candidateArr[i] = false;
      }   
      generateRemainingDigits();
    }
    if((int) key > 48 && (int) key <= 57 && isOnCell){
      puzzleState = 0;
      if(board[currX][currY].cellType == "Clue"){
        return;
      }
      if(!candidateMode){
        board[currX][currY].num = (int) key - 48;
        for(int i = 0; i < cols; i++){ //removes any candidate within the same row, column, or box as the clue filled in
          board[i][currY].candidateArr[(int) key - 48 - 1] = false;
          board[currX][i].candidateArr[(int) key - 48 - 1] = false;
          board[currX/3 * 3 + i/3][currY/3 * 3 + i%3].candidateArr[(int) key - 48 - 1] = false;
        }
      }else{
        board[currX][currY].flipCandidate((int) key - 48);
      }
      generateRemainingDigits();
    }
  }
  if(key == 'e'){ //e for easy
    generateEasySudoku();
    generateRemainingDigits();
    puzzleState = 0;
    println("Easy Sudoku Generated");
    showDifficulty = false;
  }
  
  if(key == 'm'){ //m for medium
    generateRandomSudoku();
    generateRemainingDigits();
    puzzleState = 0;
    println("Medium Sudoku Generated");
    showDifficulty = false;
  }
  
  if(key == 'h'){ //h for hard
    generateRandomSudokuVersionTwo();
    generateRemainingDigits();
    puzzleState = 0;
    println("Hard Sudoku Generated");
    showDifficulty = true;
  }
  
  if(key == 'c'){ //c for candidate
    candidateMode = !candidateMode;
  }
  if(key == 'f'){ //f for finish
    checkBoardState();
  }
}

public void mousePressed(){
  board[currX][currY].isClickedOn = false;
  isOnCell = false;
  if(mouseX > xStartPos && mouseY > yStartPos && mouseX < xStartPos + cols * cellSize && mouseY < yStartPos + rows * cellSize){
    currX = (mouseX - xStartPos) / cellSize;
    currY = (mouseY - yStartPos) / cellSize;
    board[currX][currY].isClickedOn = true;
    isOnCell = true;
  }
}

/*
Notes:
- 18 Jan: added UI (main sudoku board, candidates, right rectangle), 
added functions to select cells and highlight all cells that are relevant to the current cell
added a function to generate a sudoku board

- 19 Jan: tweaked the sudoku generation algorithm to remove duplicate solutions, 
added addOrRemoveClues, copySolution, chooseClues, removeNonClues, findAllSolutions, findMostDifferentCell, addNewClue functions
optimized the findAllSolutions function to prioritize fewest candidates first

- 20 Jan: added pencil marking function, added functionality to remaining digits function, started working on generateSudokuV2, 
fixed a bug where currBestBoard was being incorrectly updated due to board differences of more than 2 (previous changes not reverted)

- 21 Jan: optimized generateRandomSudokuV1 and V2 (removed two double for loops for the boards and removed currBestBoard as it wasn't necessary),
fixed an indexing bug where findAllSolutionsV2 was using wrong indexes (j instead of k) when removing same candidates along the column row and box.

- 21 Jan: added check if sudoku is solved, added timer

- 22 Jan: finished findAllSolutionsVersionTwo (included set theory approach and corrected the difficulty scoring), 
fixed a bug which caused duplicates to be filled in to the board due to set theory approach.
fixed a bug where the solution of generateEasySudoku doesnt match up with the actual solution (not being updated).

- 23 Jan: added a display for difficulty (only for the last sudoku generating algorithm), 
added an image to tell the solver if the configuration matches the solution or not. added highlighting for candidates.
added the ability to remove any candidates along the same row, colum or box in the most recently filled cell
added the ability to limit the difficulty rating when generating sudokus

THIS PROJECT IS NOW FINISHED (might add some more features in the future if I want to)

https://dlbeer.co.nz/articles/sudoku.html (main article used for the steps in creating the difficulty scorer and optimized solver)

https://www.sudokuwiki.org/sudoku.htm (main article used to solve and verify the actual difficulty of the sudoku)

https://www.thonky.com/sudoku/evaluate-sudoku (main article to check the number of solutions in a sudoku)
*/
class Cell{
  int x, y;
  int num = 0;
  String cellType = "Clue";
  boolean isClickedOn = false;
  boolean[] candidateArr = new boolean[cols];
  int currState = 0;
  
  Cell(int _x, int _y){
    x = _x;
    y = _y;
    for(int i = 0; i < candidateArr.length; i++){
      candidateArr[i] = false;
    }
  }
  
  public void reset(){
    num = 0;
    cellType = "Clue";
    for(int i = 0; i < candidateArr.length; i++){
      candidateArr[i] = false;
    }
  }
  
  public void flipCandidate(int n){
    candidateArr[n - 1] = !candidateArr[n - 1];
  }
  
  public void setNum(int n){
    num = n;
  }
  
  public void show(){
    int defaultX = xStartPos + x * cellSize;
    int defaultY = yStartPos + y * cellSize;
    if(isClickedOn){
      fill(0, 200, 255);
    } else{
      noFill();
    }
    strokeWeight(1);
    stroke(0);
    square(defaultX, defaultY, cellSize);
    textFont(mainCandidateFont, cellSize * 2/3);
    if(cellType == "Clue"){
      fill(0);
    }else{
      fill(0, 0, 150);
    }
    if(num > 0){
      text(num, xStartPos + x * cellSize + cellSize/2, yStartPos + y * cellSize + cellSize/2);
    }else{
      textFont(smallCandidate, cellSize / 6);
      fill(30);
      for(int i = 0; i < candidateArr.length; i++){
        if(candidateArr[i]){
          text(i + 1, defaultX + cellSize/6 + 1 + (i % 3) * cellSize/3, defaultY + cellSize/6 + 1 + (i/3) * cellSize/3);
        }
      }
    }
  }
}
public String[] findAllSolutions(String[] solutions, String[] curr, Cell[][] currBoard, boolean returnEarly){
  int filledNums = 0; //counts the number of cells with numbers filled in
  int[] nextPos = {-1, -1}; //stores the next cell position to be searched
  Integer[] minCandidates = new Integer[cols]; //stores the candidates with the smallest length
  boolean foundOnlyOne = false;
  
  //goes through the entire board
  for(int idx1 = 0; idx1 < cols; idx1++){
    for(int idx2 = 0; idx2 < rows; idx2++){
      foundOnlyOne = false;
      if(currBoard[idx1][idx2].num > 0){ //case where cell is filled
        filledNums++;
        continue;
      }
      Set<Integer> unusedNums = new HashSet<Integer>();
      for(int i = 0; i < cols; i++){ //makes a set from 1-9
        unusedNums.add(i + 1);
      }
      for(int i = 0; i < cols; i++){ //removes numbers in the same column and row of c, r
        unusedNums.remove(currBoard[i][idx2].num);
        unusedNums.remove(currBoard[idx1][i].num);
      }
      for(int i = idx1 / 3 * 3; i < idx1 / 3 * 3 + 3; i++){ //removes numbers in the same box of c, r
        for(int j = idx2 / 3 * 3; j < idx2 / 3 * 3 + 3; j++){
          unusedNums.remove(currBoard[i][j].num);
        }
      }
      //case where there are no possible candidates (therefore the sudoku is invalid)
      if(unusedNums.size() == 0){
        return solutions;
      }
      //case where a new shortest candidate list is found
      if(unusedNums.size() < minCandidates.length){
        nextPos[0] = idx1;
        nextPos[1] = idx2;       
        minCandidates = unusedNums.toArray(new Integer[unusedNums.size()]);
        if(unusedNums.size() == 1){ //case where only one candidate is possible within a cell (will never find a shorter length)
          foundOnlyOne = true;
          break;
        }
      }
    }
    if(foundOnlyOne){
      break;
    }
  }
  
  if(filledNums == cols * rows){ //case where all cells have been filled
    solutions = Arrays.copyOf(solutions, solutions.length + 1);
    solutions[solutions.length - 1] = String.join("", curr);
    return solutions;
  }
  
  if(nextPos[0] == nextPos[1] && nextPos[0] == -1){ //case where the current puzzle state is invalid
    return solutions;
  }
  
  currBranches += minCandidates.length - 1;
  
  for(int i = 0; i < minCandidates.length; i++){ //loops through all possible candidates
    currBoard[nextPos[0]][nextPos[1]].num = minCandidates[i];
    curr[nextPos[0] * cols + nextPos[1]] = str(minCandidates[i]);
    solutions = findAllSolutions(solutions, curr, currBoard, returnEarly);
    if(returnEarly && solutions.length > 1){
      break;
    }
  }
  
  currBoard[nextPos[0]][nextPos[1]].num = 0;
  curr[nextPos[0] * cols + nextPos[1]] = null;
  return solutions;
}
public int[] findMostDifferentCell(String[] solutions){
  int[] maxDiffs = {};
  int maxOccurences = 0;
  
  //goes through the elements within the first solution
  for(int i = 0; i < solutions[0].length(); i++){
    //creates a new array
    char[] currDiffs = new char[1];
    currDiffs[0] = solutions[0].substring(i, i + 1).charAt(0);
    //goes through the rest of the solutions
    for(int j = 1; j < solutions.length; j++){
      //gets the i-th digit within the current solution
      char currDigit = solutions[j].substring(i, i + 1).charAt(0);
      boolean inArray = false;
      //checks if the current digit is already is within curDiffs
      for(int k = 0; k < currDiffs.length; k++){
        if(currDiffs[k] == currDigit){
          inArray = true;
        }
      }
      //adds the digit in the case where it's not present yet
      if(!inArray){
        currDiffs = Arrays.copyOf(currDiffs, currDiffs.length + 1);
        currDiffs[currDiffs.length - 1] = currDigit;
      }
    }
    //checks if there are more differing solutions than the current max
    if(maxDiffs.length < currDiffs.length){
      //updates the index where for the most occurences
      maxOccurences = i;
      //copies all of the solutions to maxDiffs
      maxDiffs = Arrays.copyOf(maxDiffs, currDiffs.length);
      for(int temp = 0; temp < currDiffs.length; temp++){
        maxDiffs[temp] = currDiffs[temp];
      }
    }
  }
  
  int rand = PApplet.parseInt(random(0, maxDiffs.length));
  int[] retDiffVals = {maxOccurences / cols, maxOccurences % rows, Character.getNumericValue(maxDiffs[rand])};
  
  return retDiffVals;
}
/*
modified set-oriented approach:
search for all columns, rows and boxes

check all missing values within each set, and check how many positions each value can occupy (the fewer the better)

take note of the set and value with the least positions that can be occupied.

compare that set and value to the cell with the least amount of candidates available.

if set and value has less possible positions, use that with the positions and solve recursively.
else, continue as usual.
*/

public boolean presentInOtherSets(String initialSetType, int col, int row, int digitToCompare, Cell[][] currBoard){
  if(initialSetType != "ROW"){ //checks row if the initial set type is not row
    for(int i = 0; i < rows; i++){
      if (currBoard[col][i].num == digitToCompare){ //column stays constant, row changes
        return true;
      }
    }
  }
  if(initialSetType != "COL"){ //checks column if the initial set type is not column
    for(int i = 0; i < cols; i++){
      if (currBoard[i][row].num == digitToCompare){ //row stays constant, column changes
        return true;
      }
    }
  }
  if(initialSetType != "BOX"){ //checks box if the initial set type is not box
    for(int i = col / 3 * 3; i < col / 3 * 3 + 3; i++){
      for(int j = row / 3 * 3; j < row / 3 * 3 + 3; j++){
        if(currBoard[i][j].num == digitToCompare){
          return true;
        }
      }
    }
  }
  return false;
}

public int[][] searchSetAndValue(String setType, int col, int row, Cell[][] currBoard){
  int[][] cellsOfInterest = {};
  Set<Integer> unusedNums = new HashSet<Integer>();
  for(int i = 0; i < cols; i++){ //makes a set from 1-9
    unusedNums.add(i + 1);
  }
  
  //phase 1: removes filled numbers from the target set
  if(setType == "ROW"){
    for(int i = 0; i < rows; i++){ //removes numbers in the same row (row changes, col doesn't change)
      unusedNums.remove(currBoard[col][i].num);
      //checks if the cell is empty; to be added to cellsOfInterest
      if(currBoard[col][i].num <= 0){
        cellsOfInterest = Arrays.copyOf(cellsOfInterest, cellsOfInterest.length + 1);
        cellsOfInterest[cellsOfInterest.length - 1] = new int[2];
        cellsOfInterest[cellsOfInterest.length - 1][0] = col;
        cellsOfInterest[cellsOfInterest.length - 1][1] = i;
      }
    }
  }else if(setType == "COL"){
    for(int i = 0; i < cols; i++){ //removes numbers in the same column (row doesn't change, col changes)
      unusedNums.remove(currBoard[i][row].num);
      //checks if the cell is empty; to be added to cellsOfInterest
      if(currBoard[i][row].num <= 0){
        cellsOfInterest = Arrays.copyOf(cellsOfInterest, cellsOfInterest.length + 1);
        cellsOfInterest[cellsOfInterest.length - 1] = new int[2];
        cellsOfInterest[cellsOfInterest.length - 1][0] = i;
        cellsOfInterest[cellsOfInterest.length - 1][1] = row;
      }
    }
  }else if(setType == "BOX"){
    for(int i = col / 3 * 3; i < col / 3 * 3 + 3; i++){ //removes numbers in the same box of c, r
      for(int j = row / 3 * 3; j < row / 3 * 3 + 3; j++){
        unusedNums.remove(currBoard[i][j].num);
        //checks if the cell is empty; to be added to cellsOfInterest
        if(currBoard[i][j].num <= 0){
          cellsOfInterest = Arrays.copyOf(cellsOfInterest, cellsOfInterest.length + 1);
          cellsOfInterest[cellsOfInterest.length - 1] = new int[2];
          cellsOfInterest[cellsOfInterest.length - 1][0] = i;
          cellsOfInterest[cellsOfInterest.length - 1][1] = j;
        }
      }
    }
  }
  
  Integer[] unusedDigits = unusedNums.toArray(new Integer[unusedNums.size()]);
  
  //the shorter the better; default will always be the length of the board
  //(inner arrays are always length 2 to store xy values)
  //last variable holds the set type (0 = row, 1 = column, 2 = box)
  int[][] currValidPoints = {};
  int[][] bestValidPoints = new int[cols + 1][];
  
  //phase 2: checks the number of valid positions for each value within unusedNums using the other sets
  /*
    for each value, make an array of available positions. loop through each value doing the following:
    
    1. go through the target set; if current cell is filled, skip to next cell.
    2. check the other two sets associated with current cell. if either contains current value, skip to next cell.
    3. add coordinate to list of empty points for said value.
    4. after the end of the current loop, check if the created array is shorter than the current smallest one.
    4a. if its shorter, replace it as the current array. 
  */
  
  //goes through the available digits
  for(int i = 0; i < unusedDigits.length; i++){
    //reset currValidPoints before checking each digit 
    currValidPoints = Arrays.copyOf(currValidPoints, 0);
    //goes through the empty cells
    for(int j = 0; j < cellsOfInterest.length; j++){
      //checks if current cell is occupiable using current value according to the setType 
      //(there are none of the same digit within the other sets of the current cell)
      if(!presentInOtherSets(setType, cellsOfInterest[j][0], cellsOfInterest[j][1], unusedDigits[i], currBoard)){
        //adds it to currValidPoints
        currValidPoints = Arrays.copyOf(currValidPoints, currValidPoints.length + 1);
        currValidPoints[currValidPoints.length - 1] = new int[2];
        currValidPoints[currValidPoints.length - 1][0] = cellsOfInterest[j][0];
        currValidPoints[currValidPoints.length - 1][1] = cellsOfInterest[j][1];
      }
    }
    //case where a new shortest set of points are found
    if(currValidPoints.length < bestValidPoints.length - 1 && currValidPoints.length > 0){
      //updates the array
      bestValidPoints = Arrays.copyOf(bestValidPoints, currValidPoints.length);
      for(int j = 0; j < currValidPoints.length; j++){
        bestValidPoints[j] = new int[2];
        bestValidPoints[j][0] = currValidPoints[j][0];
        bestValidPoints[j][1] = currValidPoints[j][1];
      }
      //appends the value to bestValidPoints
      bestValidPoints = Arrays.copyOf(bestValidPoints, bestValidPoints.length + 1);
      bestValidPoints[bestValidPoints.length - 1] = new int[1];
      bestValidPoints[bestValidPoints.length - 1][0] = unusedDigits[i];
    }
    if(bestValidPoints.length == 2){ //case where a hidden single has been found
      break;
    }
  }
  
  return bestValidPoints;
}

public int[][] removeCandidateFromSets(int[] nextPos, int[][][] tempAllCandidates, int minCandidate){
  int[][] modifiedPoints = {};
  //goes through the column
  for(int i = 0; i < cols; i++){
    if(i == nextPos[0]){ //skips the column where the actual cell with the candidate is on
      continue;
    }
    //goes through the list of candidates in the column
    for(int j = 0; j < tempAllCandidates[i][nextPos[1]].length; j++){
      //removes same candidates along the column
      if(minCandidate == tempAllCandidates[i][nextPos[1]][j]){
        for(int k = j; k < tempAllCandidates[i][nextPos[1]].length - 1; k++){
          tempAllCandidates[i][nextPos[1]][k] = tempAllCandidates[i][nextPos[1]][k + 1];
        }
        tempAllCandidates[i][nextPos[1]] = Arrays.copyOf(tempAllCandidates[i][nextPos[1]], tempAllCandidates[i][nextPos[1]].length - 1);
        //adds the modified point to array
        modifiedPoints = Arrays.copyOf(modifiedPoints, modifiedPoints.length + 1);
        modifiedPoints[modifiedPoints.length - 1] = new int[2];
        modifiedPoints[modifiedPoints.length - 1][0] = i;
        modifiedPoints[modifiedPoints.length - 1][1] = nextPos[1];
      }
    }
  }
  //goes through the row
  for(int i = 0; i < rows; i++){
    if(i == nextPos[1]){ //skips the row where the actual cell with the candidate is on
      continue;
    }
    //goes through the list candidates in the row
    for(int j = 0; j < tempAllCandidates[nextPos[0]][i].length; j++){
      //removes same candidates along the row
      if(minCandidate == tempAllCandidates[nextPos[0]][i][j]){
        for(int k = j; k < tempAllCandidates[nextPos[0]][i].length - 1; k++){
          tempAllCandidates[nextPos[0]][i][k] = tempAllCandidates[nextPos[0]][i][k + 1];
        }
        tempAllCandidates[nextPos[0]][i] = Arrays.copyOf(tempAllCandidates[nextPos[0]][i], tempAllCandidates[nextPos[0]][i].length - 1);
        //adds the modified point to array
        modifiedPoints = Arrays.copyOf(modifiedPoints, modifiedPoints.length + 1);
        modifiedPoints[modifiedPoints.length - 1] = new int[2];
        modifiedPoints[modifiedPoints.length - 1][0] = nextPos[0];
        modifiedPoints[modifiedPoints.length - 1][1] = i;
      }
    }
  }
  //goes through the box
  for(int i = 0; i < rows; i++){
    int c = nextPos[0]/3 * 3 + i/3;
    int r = nextPos[1]/3 * 3 + i%3;
    if(c == nextPos[0] && r == nextPos[1]){ //skips the coordinate where the actual cell with the candidate is on
      continue;
    }
    //goes through the list of candidates in the box
    for(int j = 0; j < tempAllCandidates[c][r].length; j++){
      //removes same candidates in the box
      if(minCandidate == tempAllCandidates[c][r][j]){
        for(int k = j; k < tempAllCandidates[c][r].length - 1; k++){
          tempAllCandidates[c][r][k] = tempAllCandidates[c][r][k + 1];
        }
        tempAllCandidates[c][r] = Arrays.copyOf(tempAllCandidates[c][r], tempAllCandidates[c][r].length - 1);
        //adds the modified point to array
        modifiedPoints = Arrays.copyOf(modifiedPoints, modifiedPoints.length + 1);
        modifiedPoints[modifiedPoints.length - 1] = new int[2];
        modifiedPoints[modifiedPoints.length - 1][0] = c;
        modifiedPoints[modifiedPoints.length - 1][1] = r;
      }
    }
  }
  return modifiedPoints;
}

public int[][][] findAllCandidates(Cell[][] currBoard){
  int[][][] allCandidates = new int[cols][rows][];
  int[][][] invalidSudoku = {{{-1}}};
  
  for(int idx1 = 0; idx1 < cols; idx1++){
    for(int idx2 = 0; idx2 < rows; idx2++){
      if(currBoard[idx1][idx2].num > 0){ //case where cell is filled
        allCandidates[idx1][idx2] = new int[0];
        continue;
      }
      Set<Integer> unusedNums = new HashSet<Integer>();
      for(int i = 0; i < cols; i++){ //makes a set from 1-9
        unusedNums.add(i + 1);
      }
      for(int i = 0; i < cols; i++){ //removes numbers in the same column and row of c, r
        unusedNums.remove(currBoard[i][idx2].num);
        unusedNums.remove(currBoard[idx1][i].num);
      }
      for(int i = idx1 / 3 * 3; i < idx1 / 3 * 3 + 3; i++){ //removes numbers in the same box of c, r
        for(int j = idx2 / 3 * 3; j < idx2 / 3 * 3 + 3; j++){
          unusedNums.remove(currBoard[i][j].num);
        }
      }
      //case where there are no possible candidates, meaning the sudoku is unsolvable
      if(unusedNums.size() == 0){
        return invalidSudoku;
      }
      //stores all the candidates in the return array
      allCandidates[idx1][idx2] = new int[unusedNums.size()];
      Integer[] temp = unusedNums.toArray(new Integer[unusedNums.size()]);
      for(int i = 0; i < unusedNums.size(); i++){
        allCandidates[idx1][idx2][i] = temp[i];
      }
    }
  }
  return allCandidates;
}

public String[] findAllSolutionsVersionTwo(String[] solutions, String[] curr, Cell[][] currBoard, int[][][] allCandidates, boolean returnEarly){
  int filledNums = 0; //counts the number of cells with numbers filled in
  int[] nextPos = {-1, -1}; //stores the next cell position to be searched
  int[] minCandidates = new int[cols]; //stores the candidates with the smallest length
  String[] setTypes = {"ROW", "COL", "BOX"};
  int[][] setSearchCandidates = {};
  int[][] bestSetSearchCandidates = new int[cols + 1][];
  int[][][] tempAllCandidates = new int[cols][rows][];
  boolean foundSingle = false;
  
  //goes through the entire board
  for(int idx1 = 0; idx1 < cols; idx1++){
    for(int idx2 = 0; idx2 < rows; idx2++){
      //default case
      tempAllCandidates[idx1][idx2] = new int[0];
      if(currBoard[idx1][idx2].num > 0){ //case where cell is filled
        filledNums++;
        continue;
      }
      if(allCandidates[idx1][idx2].length == 0){ //case where there are no candidates for the cell (invalid solution)
        return solutions;
      }
      
      //copies the candidates within a cell to a temporary variable which will be used for the recursion part
      tempAllCandidates[idx1][idx2] = new int[allCandidates[idx1][idx2].length];
      for(int i = 0; i < allCandidates[idx1][idx2].length; i++){
        tempAllCandidates[idx1][idx2][i] = allCandidates[idx1][idx2][i];
      }
      
      if(foundSingle){ //case where a single has been found, making the whole bottom section unnecessary
        continue;
      }
      
      //case where a new shortest candidate list is found
      if(allCandidates[idx1][idx2].length < minCandidates.length){
        nextPos[0] = idx1;
        nextPos[1] = idx2;       
        minCandidates = new int[allCandidates[idx1][idx2].length];
        for(int i = 0; i < allCandidates[idx1][idx2].length; i++){
          minCandidates[i] = allCandidates[idx1][idx2][i];
        }
        if(minCandidates.length == 1){
          foundSingle = true;
        }
      }
      
      //case where a better potential cell to be filled is possible
      if(minCandidates.length > 1){
        //goes through the set types
        for(int i = 0; i < setTypes.length; i++){
          setSearchCandidates = searchSetAndValue(setTypes[i], idx1, idx2, currBoard);
          //checks if there is a new shortest array
          if(setSearchCandidates.length < bestSetSearchCandidates.length && setSearchCandidates.length > 0){
            bestSetSearchCandidates = Arrays.copyOf(bestSetSearchCandidates, setSearchCandidates.length);
            //copies the values to bestSetSearchCandidates
            for(int j = 0; j < setSearchCandidates.length; j++){
              bestSetSearchCandidates[j] = new int[setSearchCandidates[j].length];
              for(int k = 0; k < setSearchCandidates[j].length; k++){
                bestSetSearchCandidates[j][k] = setSearchCandidates[j][k];
              }
            }
          }
        }
        if(bestSetSearchCandidates.length - 1 == 1){
          foundSingle = true;
        }
      }
    }
  }
  
  if(filledNums == cols * rows){ //case where all cells have been filled
    solutions = Arrays.copyOf(solutions, solutions.length + 1);
    solutions[solutions.length - 1] = String.join("", curr);
    return solutions;
  }
  
  if(nextPos[0] == nextPos[1] && nextPos[0] == -1){ //case where the current puzzle state is invalid
    return solutions;
  }
  
  int[][] modifiedPoints = {};
      
  if(bestSetSearchCandidates.length - 1 < minCandidates.length){
    int valToUse = bestSetSearchCandidates[bestSetSearchCandidates.length - 1][0];
    
    bestSetSearchCandidates = Arrays.copyOf(bestSetSearchCandidates, bestSetSearchCandidates.length - 1);
    currBranches += (bestSetSearchCandidates.length - 1) * (bestSetSearchCandidates.length - 1);

    for(int i = 0; i < bestSetSearchCandidates.length; i++){ //loops through all possible candidates
      //removes all occurences of minCandidates[i] within its column, row and box
      modifiedPoints = removeCandidateFromSets(bestSetSearchCandidates[i], tempAllCandidates, valToUse);
  
      currBoard[bestSetSearchCandidates[i][0]][bestSetSearchCandidates[i][1]].num = valToUse;
      curr[bestSetSearchCandidates[i][0] * cols + bestSetSearchCandidates[i][1]] = str(valToUse);
            
      solutions = findAllSolutionsVersionTwo(solutions, curr, currBoard, tempAllCandidates, returnEarly);
      //restores the removed clues from tempAllCandidates
      for(int j = 0; j < modifiedPoints.length; j++){
        tempAllCandidates[modifiedPoints[j][0]][modifiedPoints[j][1]] = 
        Arrays.copyOf(tempAllCandidates[modifiedPoints[j][0]][modifiedPoints[j][1]], 
                      tempAllCandidates[modifiedPoints[j][0]][modifiedPoints[j][1]].length + 1);
                      
        tempAllCandidates[modifiedPoints[j][0]][modifiedPoints[j][1]][tempAllCandidates[modifiedPoints[j][0]][modifiedPoints[j][1]].length - 1] = valToUse;
      }
        
      currBoard[bestSetSearchCandidates[i][0]][bestSetSearchCandidates[i][1]].num = 0;
      curr[bestSetSearchCandidates[i][0] * cols + bestSetSearchCandidates[i][1]] = null;
      
      if(returnEarly && solutions.length > 1){
        break;
      }
    }
  }else{
    currBranches += (minCandidates.length - 1) * (minCandidates.length - 1);
  
    for(int i = 0; i < minCandidates.length; i++){ //loops through all possible candidates
      //removes all occurences of minCandidates[i] within its column, row and box
      modifiedPoints = removeCandidateFromSets(nextPos, tempAllCandidates, minCandidates[i]);
  
      currBoard[nextPos[0]][nextPos[1]].num = minCandidates[i];
      curr[nextPos[0] * cols + nextPos[1]] = str(minCandidates[i]);
      solutions = findAllSolutionsVersionTwo(solutions, curr, currBoard, tempAllCandidates, returnEarly);

      //restores the removed clues from tempAllCandidates
      for(int j = 0; j < modifiedPoints.length; j++){
        tempAllCandidates[modifiedPoints[j][0]][modifiedPoints[j][1]] = 
        Arrays.copyOf(tempAllCandidates[modifiedPoints[j][0]][modifiedPoints[j][1]], 
                      tempAllCandidates[modifiedPoints[j][0]][modifiedPoints[j][1]].length + 1);
                      
        tempAllCandidates[modifiedPoints[j][0]][modifiedPoints[j][1]][tempAllCandidates[modifiedPoints[j][0]][modifiedPoints[j][1]].length - 1] = minCandidates[i];
      }
      
      if(returnEarly && solutions.length > 1){
        break;
      }
    }
      
    currBoard[nextPos[0]][nextPos[1]].num = 0;
    curr[nextPos[0] * cols + nextPos[1]] = null;
  }
  return solutions;
}
//rating: extreme
//...3..2..
//4832.....
//2.......8
//.......84
//......3..
//.34.92.5.
//8.57..69.
//9..6.384.
//3.6..4725

//rating: tough
//21....3.5
//.6.21...9
//..5......
//.4.6....7
//5...9....
//.2..78.1.
//..27.....
//..49..83.
//.9...14..

//rating: extreme
//..4.8..7.
//.8.3.....
//.9.5.....
//4..6.9...
//........4
//..7..4..2
//6.....14.
//..8.135..
//135...89.

//rating: extreme
//....6.7..
//..4..9..8
//68.21...5
//7.5.8.629
//..6......
//.1.....3.
//4...2.9.6
//..2..4.7.
//...1.....

//rating: extreme
//4...8....
//.58...1..
//..93..2..
//.3....6.9
//.9.....2.
//...9.45..
//..245.9..
//..1......
//.....2375

//rating: very hard
//..8......
//..1.82...
//63...78.1
//....1..8.
//5.697....
//......4.6
//.4.2...9.
//1..34.7.2
//......3..

//rating: extreme
//47..53...
//......4..
//.68.1....
//..2.....6
//8....6..3
//39..8....
//.8.17..92
//..7...3..
//9....2..1

//rating: very hard
//.........
//159.7.2..
//2..8.9.5.
//..64....9
//.........
//..5.831.6
//..7....24
//.8.......
//6...18...

//rating: tough
//...13...6
//....29..3
//3....52..
//8......6.
//27...193.
//...2....4
//.2......9
//98.6.....
//.3.5....7

//rating: tough
//6..5....8
//.1....6..
//.8....2.5
//4...35...
//..7.9...2
//......36.
//8..6.....
//.9.78..3.
//.....4.7.

//rating: very hard
//35..17.2.
//..7......
//...4.65..
//.8.7.5...
//......268
//9.....1..
//.9....74.
//..8.....6
//..2.3...1

//rating: tough
//...547.2.
//.5.6..748
//..4.8356.
//...7..9..
//.8...1.57
//..7..9..2
//8...7...4
//.2....1..
//7.5...6..

//rating extreme:
//.7.1.....
//..8..45..
//..1..82.9
//12.......
//...3..6..
//..9..1..5
//7.....1..
//...7468..
//.....2.94

//rating: very hard
//2....13..
//.619...4.
//..9.6....
//.34.7.8..
//697......
//8........
//...1.6...
//..648..7.
//5.87....6

//rating: moderate
//4.....29.
//.5......6
//........8
//23..94...
//6........
//9...25.4.
//8.4..2.65
//....4.7..
//7.61..98.

//rating: moderate
//...4.....
//.5.....7.
//.68..9.4.
//6.....9.1
//..2.3.4..
//5..6.....
//..45..1.6
//.....6..7
//37.9..5..

//rating: very hard
//..32.....
//..5...8..
//..9567.2.
//51..3....
//..74.....
//9.6..2..4
//...1....9
//.6..5.34.
//3..6..5..

//rating: tough
//..6....4.
//..5.4.38.
//........1
//.2..9.6..
//6..1.48..
//.3.76....
//3.29.5...
//..1...93.
//97.8..5..

//rating: extreme
//.514....6
//3....9...
//....18...
//.3..86...
//....745.8
//.4.1..7..
//.1....2..
//5...43..7
//.84......

//rating: tough
//.8...26.4
//4..3.....
//2.7..9..3
//.4....9.7
//.7.....56
//5.8..3...
//96.2.....
//7.5...12.
//8.....4.9

//rating: moderate
//.5.48....
//.71.....3
//2...6..5.
//92...3..5
//..3.4....
//.1..95.2.
//.8....6..
//......17.
//.3.7.8...

//rating: very hard
//6..23...5
//4........
//..7.946.8
//.5.7.68.1
//1....9...
//.9.....52
//...98....
//..3.....9
//..8.1...4
public int[][] removeOrAddClues(Cell[][] currBoard, boolean forceAdd){
  float rand = random(0, 1);
  int counter = 0;
  int[][] res = {};
  int[][] listOfEmpties = {};
  int[][] listOfFulls = {};

  for(int i = 0; i < cols; i++){
    for(int j = 0; j < rows; j++){
      if(currBoard[i][j].num == 0){
        listOfEmpties = Arrays.copyOf(listOfEmpties, listOfEmpties.length + 1);
        listOfEmpties[listOfEmpties.length - 1] = new int[2];
        listOfEmpties[listOfEmpties.length - 1][0] = i;
        listOfEmpties[listOfEmpties.length - 1][1] = j;
      }
      if(currBoard[i][j].num > 0){
        listOfFulls = Arrays.copyOf(listOfFulls, listOfFulls.length + 1);
        listOfFulls[listOfFulls.length - 1] = new int[2];
        listOfFulls[listOfFulls.length - 1][0] = i;
        listOfFulls[listOfFulls.length - 1][1] = j;
      }
    }
  }  
  //Note: for a sudoku to be more potentially difficult, more clues need to be removed than added, 
  //hence why the random number threshold is very high
  if(forceAdd || (rand > threshold && listOfEmpties.length >= 2)){ //adds clues
    //adds two clues to the board
    while(counter < 2){
      int rand2 = PApplet.parseInt(random(0, listOfEmpties.length));
      currBoard[listOfEmpties[rand2][0]][listOfEmpties[rand2][1]].num = solution[listOfEmpties[rand2][0]][listOfEmpties[rand2][1]];
      res = Arrays.copyOf(res, res.length + 1);
      res[res.length - 1] = new int[2];
      res[res.length - 1][0] = listOfEmpties[rand2][0];
      res[res.length - 1][1] = listOfEmpties[rand2][1];
      counter++;
    }
    res = Arrays.copyOf(res, res.length + 1);
    res[res.length - 1] = new int[1];
    res[res.length - 1][0] = 1;
  }else if(listOfFulls.length >= 2){ //removes clues
    //removes two clues to the board
    while(counter < 2){
      int rand2 = PApplet.parseInt(random(0, listOfFulls.length));
      currBoard[listOfFulls[rand2][0]][listOfFulls[rand2][1]].num = 0;
      res = Arrays.copyOf(res, res.length + 1);
      res[res.length - 1] = new int[2];
      res[res.length - 1][0] = listOfFulls[rand2][0];
      res[res.length - 1][1] = listOfFulls[rand2][1];
      counter++;
    }
    res = Arrays.copyOf(res, res.length + 1);
    res[res.length - 1] = new int[1];
    res[res.length - 1][0] = 0;
  }
  return res;
}
public boolean generateSudokuConfig(int c, int r){
  if(c == cols - 1 && r == rows){ //case where the end of the board has been reached
    return true;
  }
  
  if(r >= rows){ //updates the column and row when row hits the end
    c++;
    r = 0;
  }
  
  Set<Integer> usedNums = new HashSet<Integer>();
  for(int i = 0; i < cols; i++){ //makes a set from 1-9
    usedNums.add(i + 1);
  }
  for(int i = 0; i < cols; i++){ //removes numbers in the same column and row of c, r
    usedNums.remove(board[i][r].num);
    usedNums.remove(board[c][i].num);
  }
  for(int i = c / 3 * 3; i < c / 3 * 3 + 3; i++){ //removes numbers in the same box of c, r
    for(int j = r / 3 * 3; j < r / 3 * 3 + 3; j++){
      usedNums.remove(board[i][j].num);
    }
  }
    
  if(usedNums.size() == 0){ //condition where there are no available elements to use
    return false;
  }
  
  //generates the possible candidates using usedNums
  Integer[] dummy = usedNums.toArray(new Integer[usedNums.size()]);
  int[] selection = new int[dummy.length];
  for(int i = 0; i < dummy.length; i++){
    selection[i] = dummy[i];
  }
  
  //randomizes the number priorities
  while (dummy.length > 1){
    int rand = PApplet.parseInt(random(0, dummy.length));
    int temp = dummy[rand];
    dummy[rand] = dummy[0];
    selection[rand] = selection[0];
    dummy[0] = temp;
    selection[0] = temp;
    dummy = Arrays.copyOf(dummy, dummy.length - 1);
  }
  
  boolean state = false;
  //goes through all possible configurations using backtracking
  for(int i = 0; i < selection.length; i++){
    board[c][r].num = selection[i];
    state = generateSudokuConfig(c, r + 1);
    if(state){
      break;
    }
  }
  
  if(!state){ //case where a match hasn't been found yet
    board[c][r].num = 0;
    return false;
  }
  
  return true;
}

public void generateEasySudoku(){
  timer = 0;
  finishedPuzzle = false;
  board[currX][currY].isClickedOn = false;
  isOnCell = false;
  for(int i = 0; i < cols; i++){
    for(int j = 0; j < rows; j++){
      board[i][j].num = 0;
      board[i][j].cellType = "None";
    }
  }
  generateSudokuConfig(0, 0);
  //chooeses clues at random (25 is the limit here)
  int count = 0;
  while(count < 25){
    int c = PApplet.parseInt(random(0, cols));
    int r = PApplet.parseInt(random(0, rows));
    
    if(board[c][r].cellType == "Clue"){
      continue;
    }
    
    board[c][r].cellType = "Clue";
    currSolution[c * cols + r] = str(board[c][r].num);
    count++;
  }
  //resets the non-clue cells from the board
  for(int i = 0; i < cols; i++){
    for(int j = 0; j < rows; j++){
      if(board[i][j].cellType != "Clue"){
        board[i][j].num = 0;
      }
    }
  }
  
  allSolutions = Arrays.copyOf(allSolutions, 0);
  allSolutions = findAllSolutions(allSolutions, currSolution, board, false);
  println(currBranches);
  println("Solutions: ", allSolutions.length);
  printArray(allSolutions);
  
  println("Current Board: ");
  for(int i = 0; i < board.length; i++){
    for(int j = 0; j < board[0].length; j++){
      if(board[j][i].num == 0){
        print('.');
      }else{
        print(board[j][i].num);
      }
    }
    println();
  }
  
  while(allSolutions.length > 1){
    int[] currDiff = findMostDifferentCell(allSolutions);
    if(currDiff[2] > 0){
      //adds new clue
      board[currDiff[0]][currDiff[1]].num = currDiff[2];
      board[currDiff[0]][currDiff[1]].cellType = "Clue";
      currSolution[currDiff[0] * cols + currDiff[1]] = str(currDiff[2]);
      
      allSolutions = Arrays.copyOf(allSolutions, 0);
      allSolutions = findAllSolutions(allSolutions, currSolution, board, false);
    }
  }
  
  for(int i = 0; i < cols; i++){
    for(int j = 0; j < rows; j++){
      solution[i][j] = Character.getNumericValue(allSolutions[0].charAt(i * cols + j));
    }
  }
  
  
  println("Solutions: ", allSolutions.length);
  printArray(allSolutions);
  
  println("Current Board: ");
  for(int i = 0; i < board.length; i++){
    for(int j = 0; j < board[0].length; j++){
      if(board[j][i].num == 0){
        print('.');
      }else{
        print(board[j][i].num);
      }
    }
    println();
  }
}

public void generateRandomSudokuVersionTwo(){
  timer = 0;
  finishedPuzzle = false;
  board[currX][currY].isClickedOn = false;
  isOnCell = false;
  emptySpaces = 0;
  //resets the whole board to become empty (sets all values to clues beforehand)
  resetBoard();
  //creates a new solved sudoku grid and stores it in a separate variable
  generateSudokuConfig(0, 0);
  solution = copySolution(solution);
  //initializes the number of shown clues to the entire board's dimensions and the hardest difficulty value
  int currBestBranches = 0;
  int[][][] allCandidates = new int[cols][rows][];
  Cell[][] tempBoard = new Cell[cols][rows];
  for(int i = 0; i < cols; i++){
    for(int j = 0; j < rows; j++){
      tempBoard[i][j] = new Cell(i, j);
      tempBoard[i][j].setNum(board[i][j].num);
    }
  }
  
  //first counter is to keep track of the number of changes the board will go through
  for(int counter1 = 0; counter1 < 100; counter1++){
    boolean forceAdd = false;
    //println("C1", counter1);
    //makes two placeholder boards and sets them to have the same values as the current board
    
    //stores the points being modified
    int[][] returnVals = new int[3][];
    int[][] currBestVals = new int[3][];
    currBestVals[2] = new int[1];
    currBestVals[2][0] = -1;
    //second counter to keep track of the number of times a change is being tested
    for(int counter2 = 0; counter2 < 20; counter2++){
      currBranches = 0;
      //removes or adds clues on the board
      returnVals = removeOrAddClues(tempBoard, forceAdd);
            
      //gets all potential candidates
      allCandidates = findAllCandidates(tempBoard);
      
      //case where the sudoku is solvable
      if(allCandidates.length > 1){
        //finds the amount of solutions in the new board
        allSolutions = Arrays.copyOf(allSolutions, 0);
        allSolutions = findAllSolutionsVersionTwo(allSolutions, currSolution, tempBoard, allCandidates, true);
        
        //checks if the solution is unique
        if(allSolutions.length == 1){
          forceAdd = false;
          //checks if a new hardest difficulty is found
          if(currBranches >= currBestBranches && currBranches <= (maxDiff - 100) / 100){
            //updates values
            currBestBranches = currBranches;
            //stores the new values into currBestVals
            for(int i = 0; i < returnVals.length; i++){
              currBestVals[i] = new int[returnVals[i].length];
              for(int j = 0; j < returnVals[i].length; j++){
                currBestVals[i][j] = returnVals[i][j];
              }
            }
          }
        }else{
          if(allSolutions.length > 1){ //case where multiple solutions are found (needs to add more clues to force uniqueness)
            forceAdd = true;
          }
        }
        switch(returnVals[2][0]){ //restores the state of tempBoard after addOrRemoveClues
          case 1: //removes clues again
            tempBoard[returnVals[0][0]][returnVals[0][1]].num = 0;
            tempBoard[returnVals[1][0]][returnVals[1][1]].num = 0;
            break;
          case 0: //adds back clues
            tempBoard[returnVals[0][0]][returnVals[0][1]].num = solution[returnVals[0][0]][returnVals[0][1]];
            tempBoard[returnVals[1][0]][returnVals[1][1]].num = solution[returnVals[1][0]][returnVals[1][1]];
            break;
        }
      }
    }
    //updates the final difficulty level
    finalDiff = currBestBranches * 100;
    //updates the board to match the best board from the second counter loop
    switch(currBestVals[2][0]){ //modifies the state of board and tempBoard according to currBestVals
      case 0: //removes clues again
        board[currBestVals[0][0]][currBestVals[0][1]].num = 0;
        board[currBestVals[1][0]][currBestVals[1][1]].num = 0;
        
        tempBoard[currBestVals[0][0]][currBestVals[0][1]].num = 0;
        tempBoard[currBestVals[1][0]][currBestVals[1][1]].num = 0;
        break;
      case 1: //adds back clues
        board[currBestVals[0][0]][currBestVals[0][1]].num = solution[currBestVals[0][0]][currBestVals[0][1]];
        board[currBestVals[1][0]][currBestVals[1][1]].num = solution[currBestVals[1][0]][currBestVals[1][1]];
        
        tempBoard[currBestVals[0][0]][currBestVals[0][1]].num = solution[currBestVals[0][0]][currBestVals[0][1]];
        tempBoard[currBestVals[1][0]][currBestVals[1][1]].num = solution[currBestVals[1][0]][currBestVals[1][1]];        
        break;
    }
    if(finalDiff >= maxDiff - 100){
      break;
    }
    //println("Current Board: ");
    //for(int i = 0; i < board.length; i++){
    //  for(int j = 0; j < board[0].length; j++){
    //    if(board[j][i].num == 0){
    //      print('.');
    //    }else{
    //      print(board[j][i].num);
    //    }
    //  }
    //  println();
    //}
  }
  
  for(int i = 0; i < board.length; i++){
    for(int j = 0; j < board[0].length; j++){
      if(board[i][j].num == 0){
        board[i][j].cellType = "None";
        currSolution[i * cols + j] = null;
        emptySpaces++;
      }else{
        currSolution[i * cols + j] = str(board[i][j].num);
      }
    }
  }
  finalDiff += emptySpaces;
  println("F", finalDiff, currBestBranches, emptySpaces);

  allSolutions = Arrays.copyOf(allSolutions, 0);
  allSolutions = findAllSolutions(allSolutions, currSolution, board, false);
  println("Solutions: ", allSolutions.length);
  printArray(allSolutions);
  
  println("Current Board: ");
  for(int i = 0; i < board.length; i++){
    for(int j = 0; j < board[0].length; j++){
      if(board[j][i].num == 0){
        print('.');
      }else{
        print(board[j][i].num);
      }
    }
    println();
  }
}

public void generateRandomSudoku(){
  timer = 0;
  finishedPuzzle = false;
  board[currX][currY].isClickedOn = false;
  isOnCell = false;
  emptySpaces = 0;
  //resets the whole board to become empty (sets all values to clues beforehand)
  resetBoard();
  //creates a new solved sudoku grid and stores it in a separate variable
  generateSudokuConfig(0, 0);
  solution = copySolution(solution);
  //initializes the number of shown clues to the entire board's dimensions and the hardest difficulty value
  int currBestBranches = 0;
  
  //makes two placeholder boards and sets them to have the same values as the current board
  Cell[][] tempBoard = new Cell[cols][rows];
  for(int i = 0; i < cols; i++){
    for(int j = 0; j < rows; j++){
      tempBoard[i][j] = new Cell(i, j);
      tempBoard[i][j].setNum(board[i][j].num);
    }
  }
  
  //first counter is to keep track of the number of changes the board will go through
  for(int counter1 = 0; counter1 < 100; counter1++){
    boolean forceAdd = false;
    //println("C1", counter1);
    //stores the points being modified and the currBestBoard points that were modified and the mode
    int[][] returnVals = new int[3][];
    int[][] currBestVals = new int[3][];
    currBestVals[2] = new int[1];
    currBestVals[2][0] = -1; //case where a new best board hasn't been set yet, therefore preventing the switch case from executing
    //second counter to keep track of the number of times a change is being tested
    for(int counter2 = 0; counter2 < 20; counter2++){
      currBranches = 0;
      //removes or adds clues on the board
      returnVals = removeOrAddClues(tempBoard, forceAdd);
      //finds the amount of solutions in the new board
      allSolutions = Arrays.copyOf(allSolutions, 0);
      allSolutions = findAllSolutions(allSolutions, currSolution, tempBoard, true);
      //checks if the solution is unique
      if(allSolutions.length == 1){
        forceAdd = false;
        //checks if a new hardest difficulty is found
        if(currBranches >= currBestBranches){
          //updates values
          currBestBranches = currBranches;
          //stores the new values into currBestVals
          for(int i = 0; i < returnVals.length; i++){
            currBestVals[i] = new int[returnVals[i].length];
            for(int j = 0; j < returnVals[i].length; j++){
              currBestVals[i][j] = returnVals[i][j];
            }
          }
        }
      }else{
        if(allSolutions.length > 1){ //case where multiple solutions are found (needs to add more clues to force uniqueness)
          forceAdd = true;
        }
      }
      switch(returnVals[2][0]){ //restores the state of tempBoard after addOrRemoveClues
        case 1: //removes clues again
          tempBoard[returnVals[0][0]][returnVals[0][1]].num = 0;
          tempBoard[returnVals[1][0]][returnVals[1][1]].num = 0;
          break;
        case 0: //adds back clues
          tempBoard[returnVals[0][0]][returnVals[0][1]].num = solution[returnVals[0][0]][returnVals[0][1]];
          tempBoard[returnVals[1][0]][returnVals[1][1]].num = solution[returnVals[1][0]][returnVals[1][1]];
          break;
      }
    }
    //updates the final difficulty level
    finalDiff = currBestBranches * 100;
    
    //updates the board to match the best board from the second counter loop
    switch(currBestVals[2][0]){ //modifies the state of board and tempBoard according to currBestVals
      case 0: //removes clues again
        board[currBestVals[0][0]][currBestVals[0][1]].num = 0;
        board[currBestVals[1][0]][currBestVals[1][1]].num = 0;
        
        tempBoard[currBestVals[0][0]][currBestVals[0][1]].num = 0;
        tempBoard[currBestVals[1][0]][currBestVals[1][1]].num = 0;
        break;
      case 1: //adds back clues
        board[currBestVals[0][0]][currBestVals[0][1]].num = solution[currBestVals[0][0]][currBestVals[0][1]];
        board[currBestVals[1][0]][currBestVals[1][1]].num = solution[currBestVals[1][0]][currBestVals[1][1]];
        
        tempBoard[currBestVals[0][0]][currBestVals[0][1]].num = solution[currBestVals[0][0]][currBestVals[0][1]];
        tempBoard[currBestVals[1][0]][currBestVals[1][1]].num = solution[currBestVals[1][0]][currBestVals[1][1]];        
        break;
    } 

    //println("Current Board: ");
    //for(int i = 0; i < board.length; i++){
    //  for(int j = 0; j < board[0].length; j++){
    //    if(board[j][i].num == 0){
    //      print('.');
    //    }else{
    //      print(board[j][i].num);
    //    }
    //  }
    //  println();
    //}
  }
  
  for(int i = 0; i < board.length; i++){
    for(int j = 0; j < board[0].length; j++){
      if(board[i][j].num == 0){
        board[i][j].cellType = "None";
        currSolution[i * cols + j] = null;
        emptySpaces++;
      }else{
        currSolution[i * cols + j] = str(board[i][j].num);
      }
    }
  }
  finalDiff += emptySpaces;
  println("F", finalDiff, currBestBranches, emptySpaces);

  allSolutions = Arrays.copyOf(allSolutions, 0);
  allSolutions = findAllSolutions(allSolutions, currSolution, board, false);
  println("Solutions: ", allSolutions.length);
  //printArray(allSolutions);
  
  println("Current Board: ");
  for(int i = 0; i < board.length; i++){
    for(int j = 0; j < board[0].length; j++){
      if(board[j][i].num == 0){
        print('.');
      }else{
        print(board[j][i].num);
      }
    }
    println();
  }
}


  public void settings() { size(1000, 870); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Sudoku" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
